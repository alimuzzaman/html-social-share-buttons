<?php

/**
 * Vulnerability Analyzer for HTML Social Share Buttons Plugin
 * 
 * This class implements the requirements from the PRD to:
 * 1. Parse vulnerability reports and extract structured details
 * 2. Scan code for XSS vulnerabilities and missing sanitization
 * 3. Generate developer-ready markdown reports
 */
class VulnerabilityAnalyzer {
    
    private $vulnerability_data = [];
    private $code_findings = [];
    private $scanned_files = [];
    
    /**
     * Parse vulnerability report data from the PRD
     */
    public function parseVulnerabilityReport() {
        // Extract vulnerability details from the PRD document
        $this->vulnerability_data = [
            'plugin_name' => 'Html Social share buttons',
            'plugin_slug' => 'html-social-share-buttons',
            'cve' => 'CVE-2025-9849',
            'cvss_score' => '5.3 (Medium)',
            'cvss_vector' => 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N',
            'vulnerability_type' => 'Stored Cross-Site Scripting (CWE-79)',
            'affected_versions' => 'â‰¤ 2.1.16',
            'patched' => false,
            'reporter' => 'Peter Thaleikis',
            'report_date' => 'September 3, 2025',
            'last_updated' => 'September 4, 2025',
            'description' => 'The zm_sh_btn shortcode concatenates user-supplied attributes directly into HTML without esc_attr()',
            'impact' => 'Authenticated contributors can inject JavaScript that executes on visitor interactions (e.g., mouseover)',
            'consequences' => ['cookie theft', 'session hijacking', 'PII exfiltration'],
            'root_cause' => [
                'file' => 'html-social-share.php',
                'line' => 306,
                'code' => '$output .= "<div class=\'zmshbt $__class $iconset_id $iconset_type \'>";'
            ]
        ];
        
        return $this->vulnerability_data;
    }
    
    /**
     * Extract remediation guidance from the PRD
     */
    public function getRemediationGuidance() {
        return [
            'short_instructions' => [
                'Sanitize all shortcode attributes with sanitize_text_field() or sanitize_key()',
                'Escape each attribute on output with esc_attr()',
                'Reference WordPress security documentation'
            ],
            'detailed_solution' => [
                'Validate and sanitize attributes in the zm_sh_btn handler before saving',
                'Wrap attribute outputs in esc_attr() when building HTML',
                'Add unit/integration tests that inject unsafe values and assert proper escaping',
                'Update plugin documentation to mandate WP\'s sanitization and escaping best practices'
            ]
        ];
    }
    
    /**
     * Scan PHP files for XSS vulnerabilities and missing sanitization
     */
    public function scanCodeForVulnerabilities($file_paths = []) {
        if (empty($file_paths)) {
            $file_paths = [
                'html-social-share.php',
                'shortcode.php',
                'widget.php',
                'function.php',
                'actions.php',
                'filters.php'
            ];
        }
        
        foreach ($file_paths as $file_path) {
            if (file_exists($file_path)) {
                $this->scanFile($file_path);
            }
        }
        
        return $this->code_findings;
    }
    
    /**
     * Scan individual file for vulnerabilities
     */
    private function scanFile($file_path) {
        $content = file_get_contents($file_path);
        $lines = explode("\n", $content);
        
        foreach ($lines as $line_number => $line) {
            $line_number++; // Convert to 1-based indexing
            
            // Check for unescaped HTML output with variables
            if ($this->hasUnescapedHtmlOutput($line)) {
                $this->addFinding($file_path, $line_number, $line, 'Unescaped HTML output', 
                    'Variables are concatenated directly into HTML without proper escaping. Use esc_attr(), esc_html(), or esc_url() as appropriate.');
            }
            
            // Check for missing sanitization in shortcode attributes
            if ($this->hasMissingSanitization($line)) {
                $this->addFinding($file_path, $line_number, $line, 'Missing input sanitization',
                    'User input should be sanitized using sanitize_text_field(), sanitize_key(), or appropriate WordPress sanitization functions.');
            }
            
            // Check for direct $_GET, $_POST usage without sanitization
            if ($this->hasUnsanitizedInput($line)) {
                $this->addFinding($file_path, $line_number, $line, 'Unsanitized user input',
                    'Direct usage of $_GET, $_POST, or $_REQUEST without sanitization. Always sanitize user input.');
            }
        }
        
        $this->scanned_files[] = $file_path;
    }
    
    /**
     * Check if line contains unescaped HTML output
     */
    private function hasUnescapedHtmlOutput($line) {
        // Look for HTML output with variables that aren't escaped
        $patterns = [
            '/\$\w+\s*\.=\s*["\']<[^>]*\$\w+/',  // $var .= "<tag $variable"
            '/echo\s+["\']<[^>]*\$\w+/',         // echo "<tag $variable"
            '/print\s+["\']<[^>]*\$\w+/',        // print "<tag $variable"
            '/<[^>]*\$\w+[^>]*>/',               // <tag $variable>
        ];
        
        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $line)) {
                // Check if it's already escaped
                if (!preg_match('/esc_attr\(|esc_html\(|esc_url\(/', $line)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if line has missing sanitization
     */
    private function hasMissingSanitization($line) {
        // Look for shortcode_atts or direct attribute usage without sanitization
        if (preg_match('/shortcode_atts\(/', $line)) {
            return false; // shortcode_atts itself is not the issue
        }
        
        // Look for attribute assignment without sanitization
        if (preg_match('/\$\w+\s*=\s*\$atts\[/', $line)) {
            if (!preg_match('/sanitize_text_field\(|sanitize_key\(|sanitize_email\(/', $line)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check for unsanitized user input
     */
    private function hasUnsanitizedInput($line) {
        $patterns = [
            '/\$_GET\[/',
            '/\$_POST\[/',
            '/\$_REQUEST\[/',
        ];
        
        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $line)) {
                if (!preg_match('/sanitize_|wp_unslash\(|stripslashes\(/', $line)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Add a finding to the results
     */
    private function addFinding($file, $line, $code, $issue, $fix) {
        $this->code_findings[] = [
            'file' => $file,
            'line' => $line,
            'code' => trim($code),
            'issue' => $issue,
            'suggested_fix' => $fix
        ];
    }
    
    /**
     * Generate comprehensive markdown report
     */
    public function generateReport() {
        $report = "# Vulnerability Analysis Report\n\n";
        
        // Extract vulnerability details
        $vuln_data = $this->parseVulnerabilityReport();
        $remediation = $this->getRemediationGuidance();
        
        $report .= "## Extracted Issues\n\n";
        $report .= "1. **Vulnerability Type**: {$vuln_data['vulnerability_type']}\n";
        $report .= "2. **CVE**: {$vuln_data['cve']}\n";
        $report .= "3. **CVSS Score**: {$vuln_data['cvss_score']}\n";
        $report .= "4. **Affected Versions**: {$vuln_data['affected_versions']}\n";
        $report .= "5. **Root Cause**: {$vuln_data['root_cause']['file']} line {$vuln_data['root_cause']['line']}\n";
        $report .= "6. **Impact**: {$vuln_data['impact']}\n";
        $report .= "7. **Consequences**: " . implode(', ', $vuln_data['consequences']) . "\n\n";
        
        $report .= "## Remediation Steps\n\n";
        foreach ($remediation['detailed_solution'] as $index => $step) {
            $report .= ($index + 1) . ". $step\n";
        }
        $report .= "\n";
        
        // Scan code and add findings
        $this->scanCodeForVulnerabilities();
        
        $report .= "## Additional Code Findings\n\n";
        if (empty($this->code_findings)) {
            $report .= "No additional vulnerabilities found in the scanned files.\n\n";
        } else {
            foreach ($this->code_findings as $index => $finding) {
                $report .= ($index + 1) . ". **File**: {$finding['file']} (Line {$finding['line']})\n";
                $report .= "   - **Issue**: {$finding['issue']}\n";
                $report .= "   - **Code**: `{$finding['code']}`\n";
                $report .= "   - **Suggested Fix**: {$finding['suggested_fix']}\n\n";
            }
        }
        
        $report .= "## Summary & Recommendations\n\n";
        $report .= "### Summary\n";
        $report .= "- **Primary Vulnerability**: Stored XSS in zm_sh_btn shortcode\n";
        $report .= "- **Additional Findings**: " . count($this->code_findings) . " potential security issues identified\n";
        $report .= "- **Files Scanned**: " . count($this->scanned_files) . " PHP files\n\n";
        
        $report .= "### Next Steps\n";
        $report .= "1. **Immediate Action**: Fix the reported XSS vulnerability in html-social-share.php line 306\n";
        $report .= "2. **Code Review**: Address all additional findings identified in this report\n";
        $report .= "3. **Testing**: Implement unit tests to verify proper sanitization and escaping\n";
        $report .= "4. **Security Audit**: Conduct comprehensive security review of the entire plugin\n";
        $report .= "5. **Documentation**: Update development guidelines to include security best practices\n";
        $report .= "6. **Release**: Prepare security patch release with version bump\n\n";
        
        return $report;
    }
}

// Initialize the analyzer if called directly
if (basename(__FILE__) == basename($_SERVER['SCRIPT_NAME'])) {
    $analyzer = new VulnerabilityAnalyzer();
    echo $analyzer->generateReport();
}
